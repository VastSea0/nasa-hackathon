# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QNAgICbmqsq1g6F01o-yt7ZxwNe7TB_q
"""

# Kütüphaneler ve temel setup
# !pip install earthaccess xarray cartopy matplotlib numpy

import os
import sys
import traceback
from datetime import datetime
import json

import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature

try:
    import earthaccess
except Exception:
    print("ERROR: earthaccess import failed. earthaccess configure yap.")
    raise

try:
    from google import genai
    from google.genai import types
except Exception:
    genai = None
    types = None

# Config
BBOX = (26, 36, 45, 42)
DATES = ("2025-09-01", "2025-10-02")
TIME_INDEX = 0
OUTPUT_DIR = "output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

earthaccess.login()

def search_and_open(short_name, dates=DATES, bbox=BBOX, fail_on_empty=True):
    print(f"[INFO] Searching {short_name} for {dates} @ bbox={bbox} ...")
    results = earthaccess.search_data(short_name=short_name, temporal=dates, bounding_box=bbox, cloud_hosted=True)
    if not results:
        if fail_on_empty:
            raise RuntimeError(f"No results for {short_name} {dates} {bbox}")
        return None
    files = earthaccess.open(results[0:1])
    if not files:
        raise RuntimeError(f"earthaccess.open returned no file objects for {short_name}")
    ds = xr.open_dataset(files[0])
    print(f"[INFO] Opened dataset {short_name}. Variables: {list(ds.variables.keys())[:40]} ...")
    return ds

def safe_var(ds, names):
    for n in names:
        if n in ds.variables:
            return ds[n]
    raise KeyError(f"None of {names} found. Available: {list(ds.variables.keys())[:80]}")

def subset_time_space(da, time_index=TIME_INDEX, bbox=BBOX):
    lon_min, lat_min, lon_max, lat_max = bbox
    if 'lon' in da.coords:
        lon = da.coords['lon']
        try:
            if float(lon.max()) > 180:
                da = da.assign_coords(lon=(((da.lon + 180) % 360) - 180)).sortby('lon')
        except Exception:
            pass
    if 'time' in da.dims:
        da = da.isel(time=time_index)
    return da.sel(lon=slice(lon_min, lon_max), lat=slice(lat_min, lat_max))

def build_and_plot_map(dates=DATES, savepath=None):
    print("[STEP] Fetching datasets...")
    ds_atm = search_and_open("M2T1NXSLV", dates=dates)
    ds_flx = search_and_open("M2T1NXFLX", dates=dates, fail_on_empty=False)
    ds_lnd = search_and_open("M2T1NXLND", dates=dates, fail_on_empty=False)
    ds_aer = search_and_open("M2T1NXAER", dates=dates, fail_on_empty=False)

    # Variables
    precip = None
    if ds_flx is not None:
        for cand in ["PRECTOT", "PRECTOTCORR", "PRATE", "PRECIP", "PRECC"] :
            if cand in ds_flx.variables:
                precip = ds_flx[cand]
                break
    temp = safe_var(ds_atm, ["T2M", "TMP2m", "TEMP_2M", "T2MDEW", "T10M"])
    u_wind = None
    v_wind = None
    for u_c in ["U10M", "U2M", "U_10M", "U10", "U10M_AV"]:
        if u_c in ds_atm.variables:
            u_wind = ds_atm[u_c]; break
    for v_c in ["V10M", "V2M", "V_10M", "V10", "V10M_AV"]:
        if v_c in ds_atm.variables:
            v_wind = ds_atm[v_c]; break
    soil = None
    if ds_lnd is not None:
        for cand in ["GWETROOT", "GWETPROF", "GWETTOP", "SOILM", "SMROOT"]:
            if cand in ds_lnd.variables:
                soil = ds_lnd[cand]; break
    aerosol = None
    if ds_aer is not None:
        for cand in ["TOTEXTTAU", "AOD", "AOD550", "DUEXTTAU", "DUCMASS"]:
            if cand in ds_aer.variables:
                aerosol = ds_aer[cand]; break

    # Subset
    precip_s = subset_time_space(precip) if precip is not None else None
    temp_s = subset_time_space(temp) - 273.15
    u_s = subset_time_space(u_wind) if u_wind is not None else None
    v_s = subset_time_space(v_wind) if v_wind is not None else None
    soil_s = subset_time_space(soil) if soil is not None else None
    aero_s = subset_time_space(aerosol) if aerosol is not None else None

    # Derived
    wind_speed = np.sqrt(u_s**2 + v_s**2) if (u_s is not None and v_s is not None) else None
    if soil_s is not None:
        soil_clim = float(np.nanmean(soil_s))
        drought_index = 1.0 - (soil_s / (soil_clim + 1e-9))
        drought_index = drought_index.clip(min=0.0, max=2.0)
        drought_index = (drought_index - float(drought_index.min())) / (float(drought_index.max()) - float(drought_index.min()) + 1e-9)
    elif precip_s is not None:
        precip_mean = float(np.nanmean(precip_s))
        drought_index = 1.0 - (precip_s / (precip_mean + 1e-9))
        drought_index = drought_index.clip(min=0.0, max=2.0)
        drought_index = (drought_index - float(drought_index.min())) / (float(drought_index.max()) - float(drought_index.min()) + 1e-9)
    else:
        drought_index = xr.zeros_like(temp_s) * 0.0

    precip_mm_day = precip_s * 86400.0 if precip_s is not None else None

    # Plot
    print("[STEP] Plotting combined map ...")
    fig = plt.figure(figsize=(12, 10))
    ax = plt.axes(projection=ccrs.PlateCarree())
    ax.set_extent([BBOX[0], BBOX[2], BBOX[1], BBOX[3]], crs=ccrs.PlateCarree())
    ax.add_feature(cfeature.COASTLINE, linewidth=0.6)
    ax.add_feature(cfeature.BORDERS, linewidth=0.6)
    gl = ax.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.6, linestyle='--')
    gl.top_labels = False
    gl.right_labels = False

    if precip_mm_day is not None:
        im1 = precip_mm_day.plot(ax=ax, transform=ccrs.PlateCarree(), cmap="Blues", alpha=0.85, add_colorbar=False)
        plt.colorbar(im1, ax=ax, fraction=0.037, pad=0.02).set_label("Precipitation (mm/day)")
    im2 = drought_index.plot(ax=ax, transform=ccrs.PlateCarree(), cmap="Reds", alpha=0.38, add_colorbar=False)
    plt.colorbar(im2, ax=ax, fraction=0.037, pad=0.1).set_label("Drought index (0..1)")
    temp_s.plot.contour(ax=ax, transform=ccrs.PlateCarree(), colors='k', linewidths=0.6, add_colorbar=False)
    if u_s is not None and v_s is not None:
        skip = (slice(None, None, 6), slice(None, None, 6))
        ax.quiver(u_s["lon"].values[skip[1]], u_s["lat"].values[skip[0]],
                  u_s.values[skip], v_s.values[skip], transform=ccrs.PlateCarree(), color='gray', scale=300)
    if aero_s is not None:
        aero_s.plot(ax=ax, transform=ccrs.PlateCarree(), cmap="YlGnBu_r", alpha=0.25, add_colorbar=False)
    outpath = os.path.join(OUTPUT_DIR, f"combined_map_{datetime.utcnow().strftime('%Y%m%dT%H%M%S')}.png")
    plt.savefig(outpath, dpi=220, bbox_inches='tight')
    plt.close(fig)

    # Summary
    summary = {
        'map_path': outpath,
        'precip_mean_mm_per_day': float(np.nanmean(precip_mm_day)) if precip_mm_day is not None else None,
        'temp_mean_C': float(np.nanmean(temp_s)),
        'wind_mean_m_s': float(np.nanmean(wind_speed)) if wind_speed is not None else None,
        'drought_index_mean': float(np.nanmean(drought_index)),
        'aod_mean': float(np.nanmean(aero_s)) if aero_s is not None else None
    }
    print("[DONE] analysis summary:", json.dumps(summary, indent=2))
    return summary

def call_gemini_with_analysis(analysis_dict, model_name="gemini-2.5-flash-lite", thinking_budget=0):
    if genai is None or types is None:
        print("[WARN] google-genai not installed/importable. Skipping Gemini call.")
        return None
    api_key = "skillissue"
    if not api_key:
        print("[WARN] GEMINI_API_KEY not set. Skipping Gemini call.")
        return None

    client = genai.Client(api_key=api_key)
    user_text = f"""Numeric analysis for bbox={analysis_dict.get('bbox')} dates={analysis_dict.get('dates')}:
{json.dumps(analysis_dict, indent=2)}
Please produce: 1) 3-sentence summary 2) risk bullets (agri/health/transport) 3) 3 actionable recommendations. Format as JSON with keys: summary, risks, recommendations.
"""
    contents = [ types.Content(role="user", parts=[ types.Part.from_text(text=user_text) ]) ]
    generate_content_config = types.GenerateContentConfig(
        thinking_config = types.ThinkingConfig(thinking_budget=thinking_budget),
        tools = []
    )

    print("[LLM] Sending to Gemini:", model_name)
    collected = ""
    for chunk in client.models.generate_content_stream(model=model_name, contents=contents, config=generate_content_config):
        text = getattr(chunk, "text", None)
        if text:
            print(text, end="", flush=True)
            collected += text
    print("\n[LLM] Done.")
    return collected

start_date_str = input("Lütfen başlangıç tarihini girin (YYYY-MM-DD formatında): ")
end_date_str = input("Lütfen bitiş tarihini girin (YYYY-MM-DD formatında): ")
user_dates = (start_date_str, end_date_str)

summary = build_and_plot_map(dates=user_dates)

# Eğer Gemini kullanmak istersen:
llm_text = call_gemini_with_analysis(summary)
print(llm_text)

"""# Task
Kullanıcının kendi tarih aralığını seçmesine izin veren ve sonuçları web arayüzünde gösteren bir uygulama oluşturun.

## Web uygulaması çerçevesi seçimi

### Subtask:
Flask veya Django gibi bir Python web çerçevesi seçin.

## Notebook kodunu modüler hale getirme

### Subtask:
Notebook'taki fonksiyonları (veri çekme, analiz, çizim) ayrı Python dosyalarına taşıyarak modüler hale getirin.

**Reasoning**:
Create a new Python file `weather_utils.py` and move the specified functions and constants into it, including the necessary imports.
"""

# weather_utils.py

import os
import sys
import traceback
from datetime import datetime
import json

import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature

try:
    import earthaccess
except Exception:
    print("ERROR: earthaccess import failed. earthaccess configure yap.")
    raise

try:
    from google import genai
    from google.genai import types
except Exception:
    genai = None
    types = None

# Config
BBOX = (26, 36, 45, 42)
DATES = ("2025-09-01", "2025-10-02")
TIME_INDEX = 0
OUTPUT_DIR = "output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# earthaccess.login() # This should probably be handled in the main app

def search_and_open(short_name, dates=DATES, bbox=BBOX, fail_on_empty=True):
    print(f"[INFO] Searching {short_name} for {dates} @ bbox={bbox} ...")
    results = earthaccess.search_data(short_name=short_name, temporal=dates, bounding_box=bbox, cloud_hosted=True)
    if not results:
        if fail_on_empty:
            raise RuntimeError(f"No results for {short_name} {dates} {bbox}")
        return None
    files = earthaccess.open(results[0:1])
    if not files:
        raise RuntimeError(f"earthaccess.open returned no file objects for {short_name}")
    ds = xr.open_dataset(files[0])
    print(f"[INFO] Opened dataset {short_name}. Variables: {list(ds.variables.keys())[:40]} ...")
    return ds

def safe_var(ds, names):
    for n in names:
        if n in ds.variables:
            return ds[n]
    raise KeyError(f"None of {names} found. Available: {list(ds.variables.keys())[:80]}")

def subset_time_space(da, time_index=TIME_INDEX, bbox=BBOX):
    lon_min, lat_min, lon_max, lat_max = bbox
    if 'lon' in da.coords:
        lon = da.coords['lon']
        try:
            if float(lon.max()) > 180:
                da = da.assign_coords(lon=(((da.lon + 180) % 360) - 180)).sortby('lon')
        except Exception:
            pass
    if 'time' in da.dims:
        da = da.isel(time=time_index)
    return da.sel(lon=slice(lon_min, lon_max), lat=slice(lat_min, lat_max))

def build_and_plot_map(dates=DATES, savepath=None):
    print("[STEP] Fetching datasets...")
    ds_atm = search_and_open("M2T1NXSLV", dates=dates)
    ds_flx = search_and_open("M2T1NXFLX", dates=dates, fail_on_empty=False)
    ds_lnd = search_and_open("M2T1NXLND", dates=dates, fail_on_empty=False)
    ds_aer = search_and_open("M2T1NXAER", dates=dates, fail_on_empty=False)

    # Variables
    precip = None
    if ds_flx is not None:
        for cand in ["PRECTOT", "PRECTOTCORR", "PRATE", "PRECIP", "PRECC"] :
            if cand in ds_flx.variables:
                precip = ds_flx[cand]
                break
    temp = safe_var(ds_atm, ["T2M", "TMP2m", "TEMP_2M", "T2MDEW", "T10M"])
    u_wind = None
    v_wind = None
    for u_c in ["U10M", "U2M", "U_10M", "U10", "U10M_AV"]:
        if u_c in ds_atm.variables:
            u_wind = ds_atm[u_c]; break
    for v_c in ["V10M", "V2M", "V_10M", "V10", "V10M_AV"]:
        if v_c in ds_atm.variables:
            v_wind = ds_atm[v_c]; break
    soil = None
    if ds_lnd is not None:
        for cand in ["GWETROOT", "GWETPROF", "GWETTOP", "SOILM", "SMROOT"]:
            if cand in ds_lnd.variables:
                soil = ds_lnd[cand]; break
    aerosol = None
    if ds_aer is not None:
        for cand in ["TOTEXTTAU", "AOD", "AOD550", "DUEXTTAU", "DUCMASS"]:
            if cand in ds_aer.variables:
                aerosol = ds_aer[cand]; break

    # Subset
    precip_s = subset_time_space(precip) if precip is not None else None
    temp_s = subset_time_space(temp) - 273.15
    u_s = subset_time_space(u_wind) if u_wind is not None else None
    v_s = subset_time_space(v_wind) if v_wind is not None else None
    soil_s = subset_time_space(soil) if soil is not None else None
    aero_s = subset_time_space(aerosol) if aerosol is not None else None

    # Derived
    wind_speed = np.sqrt(u_s**2 + v_s**2) if (u_s is not None and v_s is not None) else None
    if soil_s is not None:
        soil_clim = float(np.nanmean(soil_s))
        drought_index = 1.0 - (soil_s / (soil_clim + 1e-9))
        drought_index = drought_index.clip(min=0.0, max=2.0)
        drought_index = (drought_index - float(drought_index.min())) / (float(drought_index.max()) - float(drought_index.min()) + 1e-9)
    elif precip_s is not None:
        precip_mean = float(np.nanmean(precip_s))
        drought_index = 1.0 - (precip_s / (precip_mean + 1e-9))
        drought_index = drought_index.clip(min=0.0, max=2.0)
        drought_index = (drought_index - float(drought_index.min())) / (float(drought_index.max()) - float(drought_index.min()) + 1e-9)
    else:
        drought_index = xr.zeros_like(temp_s) * 0.0

    precip_mm_day = precip_s * 86400.0 if precip_s is not None else None

    # Plot
    print("[STEP] Plotting combined map ...")
    fig = plt.figure(figsize=(12, 10))
    ax = plt.axes(projection=ccrs.PlateCarree())
    ax.set_extent([BBOX[0], BBOX[2], BBOX[1], BBOX[3]], crs=ccrs.PlateCarree())
    ax.add_feature(cfeature.COASTLINE, linewidth=0.6)
    ax.add_feature(cfeature.BORDERS, linewidth=0.6)
    gl = ax.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.6, linestyle='--')
    gl.top_labels = False
    gl.right_labels = False

    if precip_mm_day is not None:
        im1 = precip_mm_day.plot(ax=ax, transform=ccrs.PlateCarree(), cmap="Blues", alpha=0.85, add_colorbar=False)
        plt.colorbar(im1, ax=ax, fraction=0.037, pad=0.02).set_label("Precipitation (mm/day)")
    im2 = drought_index.plot(ax=ax, transform=ccrs.PlateCarree(), cmap="Reds", alpha=0.38, add_colorbar=False)
    plt.colorbar(im2, ax=ax, fraction=0.037, pad=0.1).set_label("Drought index (0..1)")
    temp_s.plot.contour(ax=ax, transform=ccrs.PlateCarree(), colors='k', linewidths=0.6, add_colorbar=False)
    if u_s is not None and v_s is not None:
        skip = (slice(None, None, 6), slice(None, None, 6))
        ax.quiver(u_s["lon"].values[skip[1]], u_s["lat"].values[skip[0]],
                  u_s.values[skip], v_s.values[skip], transform=ccrs.PlateCarree(), color='gray', scale=300)
    if aero_s is not None:
        aero_s.plot(ax=ax, transform=ccrs.PlateCarree(), cmap="YlGnBu_r", alpha=0.25, add_colorbar=False)
    outpath = os.path.join(OUTPUT_DIR, f"combined_map_{datetime.utcnow().strftime('%Y%m%dT%H%M%S')}.png")
    plt.savefig(outpath, dpi=220, bbox_inches='tight')
    plt.close(fig)

    # Summary
    summary = {
        'map_path': outpath,
        'precip_mean_mm_per_day': float(np.nanmean(precip_mm_day)) if precip_mm_day is not None else None,
        'temp_mean_C': float(np.nanmean(temp_s)),
        'wind_mean_m_s': float(np.nanmean(wind_speed)) if wind_speed is not None else None,
        'drought_index_mean': float(np.nanmean(drought_index)),
        'aod_mean': float(np.nanmean(aero_s)) if aero_s is not None else None,
        'bbox': BBOX,
        'dates': dates
    }
    print("[DONE] analysis summary:", json.dumps(summary, indent=2))
    return summary

def call_gemini_with_analysis(analysis_dict, model_name="gemini-2.5-flash-lite", thinking_budget=0):
    if genai is None or types is None:
        print("[WARN] google-genai not installed/importable. Skipping Gemini call.")
        return None
    api_key = "skillissue" # Placeholder, replace with actual key retrieval
    if not api_key:
        print("[WARN] GEMINI_API_KEY not set. Skipping Gemini call.")
        return None

    client = genai.Client(api_key=api_key)
    user_text = f"""Numeric analysis for bbox={analysis_dict.get('bbox')} dates={analysis_dict.get('dates')}:
{json.dumps(analysis_dict, indent=2)}
Please produce: 1) 3-sentence summary 2) risk bullets (agri/health/transport) 3) 3 actionable recommendations. Format as JSON with keys: summary, risks, recommendations.
"""
    contents = [ types.Content(role="user", parts=[ types.Part.from_text(text=user_text) ]) ]
    generate_content_config = types.GenerateContentConfig(
        thinking_config = types.ThinkingConfig(thinking_budget=thinking_budget),
        tools = []
    )

    print("[LLM] Sending to Gemini:", model_name)
    collected = ""
    for chunk in client.models.generate_content_stream(model=model_name, contents=contents, config=generate_content_config):
        text = getattr(chunk, "text", None)
        if text:
            print(text, end="", flush=True)
            collected += text
    print("\n[LLM] Done.")
    return collected
